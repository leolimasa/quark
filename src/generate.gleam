import gleam/dict.{type Dict}
import gleam/result.{map_error, try}
import sql
import gleam/pgo
import gleam/list
import gleam/string
import gleam/int
import gleam/dynamic
import gleam/io
import justin

pub type GenerateError {
  SqlError(sql.SqlError)
  SetNotNullError(sql.SetNotNullError)
}

pub type SelectParams {
  SelectParams(
    name: String,
    query: String,
    args: Dict(String, sql.SqlCol),
    not_null: List(String),
  )
}

fn return_type_name(name: String) {
  name
  |> string.replace("_", " ")
  |> justin.pascal_case
}

fn select_function_return_type(name: String, cols: Dict(String, sql.SqlCol)) {
  let name = return_type_name(name)

  let fields =
    cols
    |> dict.values()
    |> list.map(fn(col) {
      let type_ = case col.type_ {
        sql.SqlBytea -> "BitArray"
        sql.SqlText -> "String"
        sql.SqlInt -> "Int"
        sql.SqlFloat -> "Float"
        sql.SqlBoolean -> "Bool"
      }

      let type_ = case col.nullable {
        True -> "Option(" <> type_ <> ")"
        False -> type_
      }

      "    " <> col.name <> ": " <> type_ <> "\n"
    })
    |> string.join("")

  "pub type " <> name <> " {\n" <> "  " <> name <> "(\n" <> fields <> ")\n"
  "}\n"
}

fn select_function_body(
  fun_name: String,
  query: String,
  args: List(sql.SqlCol),
  returns: Dict(String, sql.SqlCol),
) {
  let field_decoder = 
    dict.values(returns)
    |> list.sort(fn (a, b) { int.compare(a.pos, b.pos) })
    |> list.map(fn(field) {
      let type_ = case field.type_ {
        sql.SqlBytea -> "dynamic.bit_array"
        sql.SqlText -> "dynamic.string"
        sql.SqlInt -> "dynamic.int"
        sql.SqlFloat -> "dynamic.float"
        sql.SqlBoolean -> "dynamic.bool"
      }
      let type_ = case field.nullable {
        True -> "dynamic.optional(" <> type_ <> ")"
        False -> type_ 
      }
      "    use col_" <> field.name <> " <- try(dynamic.element(" <> int.to_string(field.pos) <> ", " <> type_ <> ")(row)"
    })
    |> string.join("\n")

  // TODO: generate fun_args
  // TODO: generate args dynamic var
  // TODO: generate result_mapping var

  "pub fn " <> fun_name <> "(conn: pgo.Connection, " <> fun_args <> ") {"
  <> "  let sql = \"" <> query <> "\"\n"
  <> "\n"
  <> "  use response <- pgo.execute(query, conn, args, dynamic.dynamic)\n"
  <> "  response.rows |> list.try_map(fn (row) {\n"
  <> field_decoder
  <> "\n"
  <> "    Ok(" <> result_type <> "(\n"
  <> result_mapping
  <> "    ))\n"
  <> "  })"
  <> "}"

}

pub fn select_function(
  conn: pgo.Connection,
  select_params: SelectParams,
) -> Result(String, GenerateError) {
  // Generates the final query
  let args_list = dict.values(select_params.args)
  let dummy_values =
    args_list
    |> list.map(fn(arg) { sql.dummy_value(arg.type_) })
  let query = sql.replace_vars(select_params.query, args_list)

  // Gets the columns generated by the query by creating a view
  // with dummy values.
  use returned_cols <- try(
    sql.select_cols(conn, query, dummy_values)
    |> map_error(SqlError),
  )
  // Applies the not null rules. If it's a single "*", then
  // that means set ALL columns to not null
  let returned_cols = case select_params.not_null {
    ["*"] -> sql.set_not_null(returned_cols, dict.keys(returned_cols))
    vars -> sql.set_not_null(returned_cols, vars)
  }
  use returned_cols <- try(
    returned_cols
    |> map_error(SetNotNullError),
  )

  // Generates the final function body
  let return_type = select_function_return_type(select_params.name, returned_cols)
  let fun_body = select_function_body(query, args_list, returned_cols)
  Ok(return_type <> "\n" <> fun_body)
}

import gleam/option.{Some}

pub type TestResult {
  TestResult(
    id: Int,
    str_col: String,
    int_col: option.Option(Int)
  )
}

pub fn main() {
  let db =
    pgo.connect(
      pgo.Config(
        ..pgo.default_config(),
        host: "localhost",
        database: "testdb",
        user: "test",
        password: Some("test"),
        port: 55_123,
      ),
    )
  let assert Ok(resp) = pgo.execute("select id, str_col, int_col from test_table", db, [], dynamic.dynamic)

  let typed_rows = resp.rows |> list.try_map(fn (row) {
    use col_id <- try(dynamic.element(0, dynamic.int)(row))  
    use col_str_col <- try(dynamic.element(1, dynamic.string)(row))  
    use col_int_col <- try(dynamic.element(2, dynamic.optional(dynamic.int))(row))  
  
    Ok(TestResult(
      id: col_id, 
      str_col: col_str_col,
      int_col: col_int_col
    ))
  }) 
  io.debug(typed_rows)
}
